{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:/Users/Rulian/Documents/AEM/Projetos/reactcompass/ui.frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Rulian/Documents/AEM/Projetos/reactcompass/ui.frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/Rulian/Documents/AEM/Projetos/reactcompass/ui.frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/Rulian/Documents/AEM/Projetos/reactcompass/ui.frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar Declaration = require('./declaration');\n\nvar tokenizer = require('./tokenize');\n\nvar Comment = require('./comment');\n\nvar AtRule = require('./at-rule');\n\nvar Root = require('./root');\n\nvar Rule = require('./rule');\n\nvar SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n};\n\nfunction findLastWithPosition(tokens) {\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var pos = token[3] || token[2];\n    if (pos) return pos;\n  }\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.customProperty = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        offset: 0,\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  _createClass(Parser, [{\n    key: \"createTokenizer\",\n    value: function createTokenizer() {\n      this.tokenizer = tokenizer(this.input);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var token;\n\n      while (!this.tokenizer.endOfFile()) {\n        token = this.tokenizer.nextToken();\n\n        switch (token[0]) {\n          case 'space':\n            this.spaces += token[1];\n            break;\n\n          case ';':\n            this.freeSemicolon(token);\n            break;\n\n          case '}':\n            this.end(token);\n            break;\n\n          case 'comment':\n            this.comment(token);\n            break;\n\n          case 'at-word':\n            this.atrule(token);\n            break;\n\n          case '{':\n            this.emptyRule(token);\n            break;\n\n          default:\n            this.other(token);\n            break;\n        }\n      }\n\n      this.endFile();\n    }\n  }, {\n    key: \"comment\",\n    value: function comment(token) {\n      var node = new Comment();\n      this.init(node, token[2]);\n      node.source.end = this.getPosition(token[3] || token[2]);\n      var text = token[1].slice(2, -2);\n\n      if (/^\\s*$/.test(text)) {\n        node.text = '';\n        node.raws.left = text;\n        node.raws.right = '';\n      } else {\n        var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n        node.text = match[2];\n        node.raws.left = match[1];\n        node.raws.right = match[3];\n      }\n    }\n  }, {\n    key: \"emptyRule\",\n    value: function emptyRule(token) {\n      var node = new Rule();\n      this.init(node, token[2]);\n      node.selector = '';\n      node.raws.between = '';\n      this.current = node;\n    }\n  }, {\n    key: \"other\",\n    value: function other(start) {\n      var end = false;\n      var type = null;\n      var colon = false;\n      var bracket = null;\n      var brackets = [];\n      var customProperty = start[1].startsWith('--');\n      var tokens = [];\n      var token = start;\n\n      while (token) {\n        type = token[0];\n        tokens.push(token);\n\n        if (type === '(' || type === '[') {\n          if (!bracket) bracket = token;\n          brackets.push(type === '(' ? ')' : ']');\n        } else if (customProperty && colon && type === '{') {\n          if (!bracket) bracket = token;\n          brackets.push('}');\n        } else if (brackets.length === 0) {\n          if (type === ';') {\n            if (colon) {\n              this.decl(tokens, customProperty);\n              return;\n            } else {\n              break;\n            }\n          } else if (type === '{') {\n            this.rule(tokens);\n            return;\n          } else if (type === '}') {\n            this.tokenizer.back(tokens.pop());\n            end = true;\n            break;\n          } else if (type === ':') {\n            colon = true;\n          }\n        } else if (type === brackets[brackets.length - 1]) {\n          brackets.pop();\n          if (brackets.length === 0) bracket = null;\n        }\n\n        token = this.tokenizer.nextToken();\n      }\n\n      if (this.tokenizer.endOfFile()) end = true;\n      if (brackets.length > 0) this.unclosedBracket(bracket);\n\n      if (end && colon) {\n        if (!customProperty) {\n          while (tokens.length) {\n            token = tokens[tokens.length - 1][0];\n            if (token !== 'space' && token !== 'comment') break;\n            this.tokenizer.back(tokens.pop());\n          }\n        }\n\n        this.decl(tokens, customProperty);\n      } else {\n        this.unknownWord(tokens);\n      }\n    }\n  }, {\n    key: \"rule\",\n    value: function rule(tokens) {\n      tokens.pop();\n      var node = new Rule();\n      this.init(node, tokens[0][2]);\n      node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n      this.raw(node, 'selector', tokens);\n      this.current = node;\n    }\n  }, {\n    key: \"decl\",\n    value: function decl(tokens, customProperty) {\n      var node = new Declaration();\n      this.init(node, tokens[0][2]);\n      var last = tokens[tokens.length - 1];\n\n      if (last[0] === ';') {\n        this.semicolon = true;\n        tokens.pop();\n      }\n\n      node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n\n      while (tokens[0][0] !== 'word') {\n        if (tokens.length === 1) this.unknownWord(tokens);\n        node.raws.before += tokens.shift()[1];\n      }\n\n      node.source.start = this.getPosition(tokens[0][2]);\n      node.prop = '';\n\n      while (tokens.length) {\n        var type = tokens[0][0];\n\n        if (type === ':' || type === 'space' || type === 'comment') {\n          break;\n        }\n\n        node.prop += tokens.shift()[1];\n      }\n\n      node.raws.between = '';\n      var token;\n\n      while (tokens.length) {\n        token = tokens.shift();\n\n        if (token[0] === ':') {\n          node.raws.between += token[1];\n          break;\n        } else {\n          if (token[0] === 'word' && /\\w/.test(token[1])) {\n            this.unknownWord([token]);\n          }\n\n          node.raws.between += token[1];\n        }\n      }\n\n      if (node.prop[0] === '_' || node.prop[0] === '*') {\n        node.raws.before += node.prop[0];\n        node.prop = node.prop.slice(1);\n      }\n\n      var firstSpaces = [];\n      var next;\n\n      while (tokens.length) {\n        next = tokens[0][0];\n        if (next !== 'space' && next !== 'comment') break;\n        firstSpaces.push(tokens.shift());\n      }\n\n      this.precheckMissedSemicolon(tokens);\n\n      for (var i = tokens.length - 1; i >= 0; i--) {\n        token = tokens[i];\n\n        if (token[1].toLowerCase() === '!important') {\n          node.important = true;\n          var string = this.stringFrom(tokens, i);\n          string = this.spacesFromEnd(tokens) + string;\n          if (string !== ' !important') node.raws.important = string;\n          break;\n        } else if (token[1].toLowerCase() === 'important') {\n          var cache = tokens.slice(0);\n          var str = '';\n\n          for (var j = i; j > 0; j--) {\n            var _type = cache[j][0];\n\n            if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n              break;\n            }\n\n            str = cache.pop()[1] + str;\n          }\n\n          if (str.trim().indexOf('!') === 0) {\n            node.important = true;\n            node.raws.important = str;\n            tokens = cache;\n          }\n        }\n\n        if (token[0] !== 'space' && token[0] !== 'comment') {\n          break;\n        }\n      }\n\n      var hasWord = tokens.some(function (i) {\n        return i[0] !== 'space' && i[0] !== 'comment';\n      });\n\n      if (hasWord) {\n        node.raws.between += firstSpaces.map(function (i) {\n          return i[1];\n        }).join('');\n        firstSpaces = [];\n      }\n\n      this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n\n      if (node.value.includes(':') && !customProperty) {\n        this.checkMissedSemicolon(tokens);\n      }\n    }\n  }, {\n    key: \"atrule\",\n    value: function atrule(token) {\n      var node = new AtRule();\n      node.name = token[1].slice(1);\n\n      if (node.name === '') {\n        this.unnamedAtrule(node, token);\n      }\n\n      this.init(node, token[2]);\n      var type;\n      var prev;\n      var shift;\n      var last = false;\n      var open = false;\n      var params = [];\n      var brackets = [];\n\n      while (!this.tokenizer.endOfFile()) {\n        token = this.tokenizer.nextToken();\n        type = token[0];\n\n        if (type === '(' || type === '[') {\n          brackets.push(type === '(' ? ')' : ']');\n        } else if (type === '{' && brackets.length > 0) {\n          brackets.push('}');\n        } else if (type === brackets[brackets.length - 1]) {\n          brackets.pop();\n        }\n\n        if (brackets.length === 0) {\n          if (type === ';') {\n            node.source.end = this.getPosition(token[2]);\n            this.semicolon = true;\n            break;\n          } else if (type === '{') {\n            open = true;\n            break;\n          } else if (type === '}') {\n            if (params.length > 0) {\n              shift = params.length - 1;\n              prev = params[shift];\n\n              while (prev && prev[0] === 'space') {\n                prev = params[--shift];\n              }\n\n              if (prev) {\n                node.source.end = this.getPosition(prev[3] || prev[2]);\n              }\n            }\n\n            this.end(token);\n            break;\n          } else {\n            params.push(token);\n          }\n        } else {\n          params.push(token);\n        }\n\n        if (this.tokenizer.endOfFile()) {\n          last = true;\n          break;\n        }\n      }\n\n      node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n      if (params.length) {\n        node.raws.afterName = this.spacesAndCommentsFromStart(params);\n        this.raw(node, 'params', params);\n\n        if (last) {\n          token = params[params.length - 1];\n          node.source.end = this.getPosition(token[3] || token[2]);\n          this.spaces = node.raws.between;\n          node.raws.between = '';\n        }\n      } else {\n        node.raws.afterName = '';\n        node.params = '';\n      }\n\n      if (open) {\n        node.nodes = [];\n        this.current = node;\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(token) {\n      if (this.current.nodes && this.current.nodes.length) {\n        this.current.raws.semicolon = this.semicolon;\n      }\n\n      this.semicolon = false;\n      this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n      this.spaces = '';\n\n      if (this.current.parent) {\n        this.current.source.end = this.getPosition(token[2]);\n        this.current = this.current.parent;\n      } else {\n        this.unexpectedClose(token);\n      }\n    }\n  }, {\n    key: \"endFile\",\n    value: function endFile() {\n      if (this.current.parent) this.unclosedBlock();\n\n      if (this.current.nodes && this.current.nodes.length) {\n        this.current.raws.semicolon = this.semicolon;\n      }\n\n      this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    }\n  }, {\n    key: \"freeSemicolon\",\n    value: function freeSemicolon(token) {\n      this.spaces += token[1];\n\n      if (this.current.nodes) {\n        var prev = this.current.nodes[this.current.nodes.length - 1];\n\n        if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n          prev.raws.ownSemicolon = this.spaces;\n          this.spaces = '';\n        }\n      }\n    } // Helpers\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(offset) {\n      var pos = this.input.fromOffset(offset);\n      return {\n        offset: offset,\n        line: pos.line,\n        column: pos.col\n      };\n    }\n  }, {\n    key: \"init\",\n    value: function init(node, offset) {\n      this.current.push(node);\n      node.source = {\n        start: this.getPosition(offset),\n        input: this.input\n      };\n      node.raws.before = this.spaces;\n      this.spaces = '';\n      if (node.type !== 'comment') this.semicolon = false;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw(node, prop, tokens, customProperty) {\n      var token, type;\n      var length = tokens.length;\n      var value = '';\n      var clean = true;\n      var next, prev;\n\n      for (var i = 0; i < length; i += 1) {\n        token = tokens[i];\n        type = token[0];\n\n        if (type === 'space' && i === length - 1 && !customProperty) {\n          clean = false;\n        } else if (type === 'comment') {\n          prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n          next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n\n          if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n            if (value.slice(-1) === ',') {\n              clean = false;\n            } else {\n              value += token[1];\n            }\n          } else {\n            clean = false;\n          }\n        } else {\n          value += token[1];\n        }\n      }\n\n      if (!clean) {\n        var raw = tokens.reduce(function (all, i) {\n          return all + i[1];\n        }, '');\n        node.raws[prop] = {\n          value: value,\n          raw: raw\n        };\n      }\n\n      node[prop] = value;\n    }\n  }, {\n    key: \"spacesAndCommentsFromEnd\",\n    value: function spacesAndCommentsFromEnd(tokens) {\n      var lastTokenType;\n      var spaces = '';\n\n      while (tokens.length) {\n        lastTokenType = tokens[tokens.length - 1][0];\n        if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n        spaces = tokens.pop()[1] + spaces;\n      }\n\n      return spaces;\n    }\n  }, {\n    key: \"spacesAndCommentsFromStart\",\n    value: function spacesAndCommentsFromStart(tokens) {\n      var next;\n      var spaces = '';\n\n      while (tokens.length) {\n        next = tokens[0][0];\n        if (next !== 'space' && next !== 'comment') break;\n        spaces += tokens.shift()[1];\n      }\n\n      return spaces;\n    }\n  }, {\n    key: \"spacesFromEnd\",\n    value: function spacesFromEnd(tokens) {\n      var lastTokenType;\n      var spaces = '';\n\n      while (tokens.length) {\n        lastTokenType = tokens[tokens.length - 1][0];\n        if (lastTokenType !== 'space') break;\n        spaces = tokens.pop()[1] + spaces;\n      }\n\n      return spaces;\n    }\n  }, {\n    key: \"stringFrom\",\n    value: function stringFrom(tokens, from) {\n      var result = '';\n\n      for (var i = from; i < tokens.length; i++) {\n        result += tokens[i][1];\n      }\n\n      tokens.splice(from, tokens.length - from);\n      return result;\n    }\n  }, {\n    key: \"colon\",\n    value: function colon(tokens) {\n      var brackets = 0;\n      var token, type, prev;\n\n      var _iterator = _createForOfIteratorHelper(tokens.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              i = _step$value[0],\n              element = _step$value[1];\n\n          token = element;\n          type = token[0];\n\n          if (type === '(') {\n            brackets += 1;\n          }\n\n          if (type === ')') {\n            brackets -= 1;\n          }\n\n          if (brackets === 0 && type === ':') {\n            if (!prev) {\n              this.doubleColon(token);\n            } else if (prev[0] === 'word' && prev[1] === 'progid') {\n              continue;\n            } else {\n              return i;\n            }\n          }\n\n          prev = token;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    } // Errors\n\n  }, {\n    key: \"unclosedBracket\",\n    value: function unclosedBracket(bracket) {\n      throw this.input.error('Unclosed bracket', {\n        offset: bracket[2]\n      }, {\n        offset: bracket[2] + 1\n      });\n    }\n  }, {\n    key: \"unknownWord\",\n    value: function unknownWord(tokens) {\n      throw this.input.error('Unknown word', {\n        offset: tokens[0][2]\n      }, {\n        offset: tokens[0][2] + tokens[0][1].length\n      });\n    }\n  }, {\n    key: \"unexpectedClose\",\n    value: function unexpectedClose(token) {\n      throw this.input.error('Unexpected }', {\n        offset: token[2]\n      }, {\n        offset: token[2] + 1\n      });\n    }\n  }, {\n    key: \"unclosedBlock\",\n    value: function unclosedBlock() {\n      var pos = this.current.source.start;\n      throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n  }, {\n    key: \"doubleColon\",\n    value: function doubleColon(token) {\n      throw this.input.error('Double colon', {\n        offset: token[2]\n      }, {\n        offset: token[2] + token[1].length\n      });\n    }\n  }, {\n    key: \"unnamedAtrule\",\n    value: function unnamedAtrule(node, token) {\n      throw this.input.error('At-rule without name', {\n        offset: token[2]\n      }, {\n        offset: token[2] + token[1].length\n      });\n    }\n  }, {\n    key: \"precheckMissedSemicolon\",\n    value: function\n      /* tokens */\n    precheckMissedSemicolon() {// Hook for Safe Parser\n    }\n  }, {\n    key: \"checkMissedSemicolon\",\n    value: function checkMissedSemicolon(tokens) {\n      var colon = this.colon(tokens);\n      if (colon === false) return;\n      var founded = 0;\n      var token;\n\n      for (var j = colon - 1; j >= 0; j--) {\n        token = tokens[j];\n\n        if (token[0] !== 'space') {\n          founded += 1;\n          if (founded === 2) break;\n        }\n      } // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n      // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n      // And because we need it after that one we do +1 to get the next one.\n\n\n      throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n    }\n  }]);\n\n  return Parser;\n}();\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/Rulian/Documents/AEM/Projetos/reactcompass/ui.frontend/node_modules/postcss/lib/parser.js"],"names":["Declaration","require","tokenizer","Comment","AtRule","Root","Rule","SAFE_COMMENT_NEIGHBOR","empty","space","findLastWithPosition","tokens","i","length","token","pos","Parser","input","root","current","spaces","semicolon","customProperty","createTokenizer","source","start","offset","line","column","endOfFile","nextToken","freeSemicolon","end","comment","atrule","emptyRule","other","endFile","node","init","getPosition","text","slice","test","raws","left","right","match","selector","between","type","colon","bracket","brackets","startsWith","push","decl","rule","back","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","last","before","shift","prop","firstSpaces","next","precheckMissedSemicolon","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","j","trim","indexOf","hasWord","some","map","join","concat","value","includes","checkMissedSemicolon","name","unnamedAtrule","prev","open","params","afterName","spacesAndCommentsFromStart","nodes","after","parent","unexpectedClose","unclosedBlock","ownSemicolon","fromOffset","col","clean","reduce","all","lastTokenType","from","result","splice","entries","element","doubleColon","error","founded","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n}\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}